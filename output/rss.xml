<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>gramanas &gt;&gt; blog</title><link>https://gramanas.github.io/</link><description>LLVM development log for GSoC 2018</description><atom:link href="https://gramanas.github.io/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2018 &lt;a href="mailto:anastasis.gramm2@gmail.com"&gt;Anastasis Grammenos&lt;/a&gt; </copyright><lastBuildDate>Fri, 29 Jun 2018 15:07:27 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Finding and fixing DebugInfo related bugs</title><link>https://gramanas.github.io/posts/finding-and-fixing-debuginfo-related-bugs/</link><dc:creator>Anastasis Grammenos</dc:creator><description>&lt;p&gt;
The last few weeks that I haven't posted any updates have been pretty laborsome.
&lt;/p&gt;

&lt;p&gt;
For one, I had finals in the university, and all of the five classes I was being tested on
were on the same week. This was both good and bad. Good for GSoC because it didn't
consume much of the month, but OTOH bad for my performance because I was giving
one exam after the other.
&lt;/p&gt;

&lt;p&gt;
So far the results came for 2 classes and I passed them both, so that's good!
&lt;/p&gt;

&lt;p&gt;
On the LLVM side of things, I was struggling with an InstCombine &lt;a href="https://reviews.llvm.org/D48331"&gt;bug&lt;/a&gt; in 
debug intrinsics loss. It took way more time than anticipated to figure out
what was going on, and how we should fix it. All this time wasn't wasted though,
since I gained valuable experiences! 
&lt;/p&gt;

&lt;p&gt;
Let's talk about those now.
&lt;/p&gt;

&lt;div id="outline-container-orgfa81cc0" class="outline-2"&gt;
&lt;h2 id="orgfa81cc0"&gt;Finding bugs&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgfa81cc0"&gt;
&lt;p&gt;
Greg has created a meta &lt;a href="https://bugs.llvm.org/show_bug.cgi?id=37953"&gt;bug&lt;/a&gt; to group debugify failures across all passes
and have a centralized reference point.
&lt;/p&gt;

&lt;p&gt;
I've already made a &lt;a href="https://gramanas.github.io/posts/finding-debuginfo-loss/"&gt;post&lt;/a&gt; describing a way to find such bugs. Although
Greg's process seems to be a bit different, since it starts from the 
source instead of relying on already crated IR.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1c6e31f" class="outline-3"&gt;
&lt;h3 id="org1c6e31f"&gt;Zeroing to the problem&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org1c6e31f"&gt;
&lt;p&gt;
First, one has to understand at least what the description of the culprit pass
is, and how it's used to optimize code.
&lt;/p&gt;

&lt;p&gt;
Then in the relatively more simple case of missing Debug Location, it's a matter
of running opt with the culprit pass through a debugger, stopping whenever the 
instruction with the missing DL is created and reading through the backtrace 
to find when and where in the code the DL is dropped. Usually the fix is a 
pretty simple one like on &lt;a href="https://reviews.llvm.org/rL335904"&gt;r335904&lt;/a&gt; and &lt;a href="https://reviews.llvm.org/D48769"&gt;D48769&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
In the case of a missing variable though it's more complex. In the aforementioned
InstCombine &lt;a href="https://reviews.llvm.org/D48331"&gt;bug&lt;/a&gt; for example the fix is not clear at all, since the proper API is not
in place yet. Vedant is tackling this by first &lt;a href="https://reviews.llvm.org/rL335144"&gt;creating&lt;/a&gt; a utility and currently &lt;a href="https://reviews.llvm.org/D48676"&gt;enhancing&lt;/a&gt; it.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf00022d" class="outline-2"&gt;
&lt;h2 id="orgf00022d"&gt;Testing that it works&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf00022d"&gt;
&lt;p&gt;
Another important thing after fixing those bugs, is adding regression tests
to make sure they won't appear again. To that end the &lt;code&gt;-debugify&lt;/code&gt; pass 
is especially helpful. (NOTE: &lt;code&gt;-debugify&lt;/code&gt; is the pass that applies 
Debug Info to every instruction on a module, &lt;code&gt;-check-debugify&lt;/code&gt; is the one
that actually does the checks for DI preservation, after a pass has run)
&lt;/p&gt;

&lt;p&gt;
Most of the above patches contain this new kinds of test. Basically
we try to incorporate a RUN line like &lt;code&gt;opt -debugify -culprit-pass&lt;/code&gt;,
to the existing tests and add checks for the preservation of DI.
&lt;/p&gt;

&lt;p&gt;
An important part of the &lt;code&gt;-debugify&lt;/code&gt; pass is that it should be stable enough
to enable it's usage on regression tests..
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge289a82" class="outline-3"&gt;
&lt;h3 id="orge289a82"&gt;Finding the test files to modify&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orge289a82"&gt;
&lt;p&gt;
Another cool trick Vedant taught me is the usage of assertions to check
whether a sample input IR is passing through the code we juts modified.
&lt;/p&gt;

&lt;p&gt;
For example in &lt;a href="https://reviews.llvm.org/rL335904"&gt;r335904&lt;/a&gt; and &lt;a href="https://reviews.llvm.org/D48769"&gt;D48769&lt;/a&gt;, after I found where in the code the DL
was dropped, using lldb and the sample code from Greg's report, I had to find 
an existing test that went through the same code path as Greg's sample code.
&lt;/p&gt;

&lt;p&gt;
In the case of the LoopVectorize pass, there are &lt;b&gt;&lt;b&gt;a lot&lt;/b&gt;&lt;/b&gt; of tests to look through.
The following assertion trick makes the process as simple as it could ever get.
&lt;/p&gt;

&lt;p&gt;
First I add a failing assertion next to the code I modified:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;NewAI&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setDebugLoc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AI&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getDebugLoc&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="s"&gt;"gotcha"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Then I modify the bash loop from &lt;a href="https://gramanas.github.io/posts/finding-debuginfo-loss/"&gt;here&lt;/a&gt; to just run the pass over all the tests.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; i in &lt;span class="k"&gt;$(&lt;/span&gt;ls ~/code/llvm/test/Culprit/Pass/*.ll -1&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; 
    &lt;span class="nb"&gt;echo&lt;/span&gt; -e &lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="s2"&gt;":\n-------"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    opt -cuplrit-pass -disable-output &lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; -e &lt;span class="s2"&gt;"-------\n"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;span class="k"&gt;done&lt;/span&gt; &amp;gt; results &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Then reading through the resulting file, you can clearly see in what test file
there was an assertion, and that means there is a test there that can be used
to test the DI preservation.
&lt;/p&gt;

&lt;p&gt;
Also the assertion backtrace also shows in what IR function the assertion was
triggered so it's easy to find what function to add the DI preservation tests at,
even if the file has many different tests.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://gramanas.github.io/posts/finding-and-fixing-debuginfo-related-bugs/</guid><pubDate>Fri, 29 Jun 2018 13:10:52 GMT</pubDate></item><item><title>InstCombine debugging reference</title><link>https://gramanas.github.io/posts/instcombine-debugging-reference/</link><dc:creator>Anastasis Grammenos</dc:creator><description>&lt;p&gt;
Instruction Combine is a crucial pass occurring in the middle of the pipeline.
It consolidates redundant instructions and while doing that it doesn't always get
the Debug Info right.
&lt;/p&gt;

&lt;div id="outline-container-org30cbab4" class="outline-2"&gt;
&lt;h2 id="org30cbab4"&gt;Code structure&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org30cbab4"&gt;
&lt;p&gt;
The pass is split into many different files. The class definition
along with the definition of the instruction work-list is 
in &lt;code&gt;llvm/include/llvm/Transforms/InstCombine&lt;/code&gt; while the implementation lies
in &lt;code&gt;llvm/lib/Transforms/InstCombine&lt;/code&gt;. The main cpp file is 
&lt;code&gt;/home/gramanas/code/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
The pass runs on a function level.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1af67ab" class="outline-2"&gt;
&lt;h2 id="org1af67ab"&gt;Debugging&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1af67ab"&gt;
&lt;p&gt;
In order to see what the pass is doing step by step use this:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;opt -debug-only&lt;span class="o"&gt;=&lt;/span&gt;instcombine -instcombine sample.ll
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org37c9ba9" class="outline-2"&gt;
&lt;h2 id="org37c9ba9"&gt;Example&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org37c9ba9"&gt;
&lt;p&gt;
The following llvm-ir snippet:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;define &amp;lt;2 x i64&amp;gt; @test3(&amp;lt;2 x i64&amp;gt; %A) {
  %trunc = trunc &amp;lt;2 x i64&amp;gt; %A to &amp;lt;2 x i32&amp;gt;
  %and = and &amp;lt;2 x i32&amp;gt; %trunc, &amp;lt;i32 23, i32 42&amp;gt;
  %zext = zext &amp;lt;2 x i32&amp;gt; %and to &amp;lt;2 x i64&amp;gt;
  ret &amp;lt;2 x i64&amp;gt; %zext
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
gets reduced to this:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;define &amp;lt;2 x i64&amp;gt; @test3(&amp;lt;2 x i64&amp;gt; %A) {                                                                                                                                              
  %and = and &amp;lt;2 x i64&amp;gt; %A, &amp;lt;i64 23, i64 42&amp;gt;                                                                                                                                          
  ret &amp;lt;2 x i64&amp;gt; %and                                                                                                                                                                 
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
after running &lt;code&gt;instcombine&lt;/code&gt; on it.
&lt;/p&gt;

&lt;p&gt;
We are left with two dbg.value intrinsics missing.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://gramanas.github.io/posts/instcombine-debugging-reference/</guid><pubDate>Sat, 16 Jun 2018 09:08:31 GMT</pubDate></item><item><title>SROA debug experience and dexter thoughts</title><link>https://gramanas.github.io/posts/sroa-debug-experience-and-dexter-thoughts/</link><dc:creator>Anastasis Grammenos</dc:creator><description>&lt;div id="outline-container-org6f46e3b" class="outline-2"&gt;
&lt;h2 id="org6f46e3b"&gt;Introduction&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org6f46e3b"&gt;
&lt;p&gt;
The past weeks the efforts were focused around the Scalar Replacement of
Aggregates pass. This is an early stage pass and thus the amount of debug
info loss should be minimized cause it impacts the whole compiler a lot more.
&lt;/p&gt;

&lt;p&gt;
Our contribution has been to systematically show that IR-level 
invariants on debug info are being respected by SROA/mem2reg.
&lt;/p&gt;

&lt;p&gt;
The debugify pass with the newly implemented &lt;a href="https://reviews.llvm.org/D46525"&gt;debugify-each&lt;/a&gt; option was the
main tool used.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org549de8f" class="outline-2"&gt;
&lt;h2 id="org549de8f"&gt;Process&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org549de8f"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Run sroa through samples of IR&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; opt -debugify -sroa -check-debugify &lt;span class="o"&gt;{&lt;/span&gt;ir_file.ll&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;When finding errors I created a reduced IR test case like &lt;a href="https://reviews.llvm.org/D47097"&gt;here&lt;/a&gt; and &lt;a href="https://reviews.llvm.org/D47720"&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Fix the failing tests&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org66c05c4" class="outline-2"&gt;
&lt;h2 id="org66c05c4"&gt;Results&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org66c05c4"&gt;
&lt;p&gt;
I made a &lt;a href="https://gramanas.github.io/posts/sroa-on-amalgamated-sqlite-source/"&gt;report&lt;/a&gt; after ruining SROA on the amalgamated sqlite source.
The results were a clear indication that SROA was doing it's job just fine
and the little instructions without DebugLoc were produced from clang and it
wasn't SROA/mem2reg's fault.
&lt;/p&gt;

&lt;p&gt;
After applying the above clang patches the results are even better.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgfbe68f2" class="outline-2"&gt;
&lt;h2 id="orgfbe68f2"&gt;Comparing the results to &lt;a href="https://llvm.org/devmtg/2018-04/slides/Bedwell-Measuring_the_User_Debugging_Experience.pdf"&gt;dexter&lt;/a&gt; ones&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgfbe68f2"&gt;
&lt;p&gt;
Dexter scored SROA low.
&lt;/p&gt;

&lt;p&gt;
As Greg (dexter's creator) mentions the dexter results don't have
to indicate that there is some kind of bug
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
My standard disclaimer with all results from this tool is that a
non-perfect debugging experience score is not necessarily indicative of
something wrong, but should be looked at in conjunction with all the other
factors such as what the pass is trying to achieve optimization-wise.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
And such is the case with SROA.
&lt;/p&gt;

&lt;p&gt;
A &lt;a href="https://bugs.llvm.org/show_bug.cgi?id=37682"&gt;bug report&lt;/a&gt; has been filed explaining the problem.
&lt;/p&gt;

&lt;p&gt;
Basically after running SROA/mem2reg the optimizations will
at many cases result in weird stepping behavior in the debugger.
This is normal since that's the whole point of passes like SROA and
LICM: to reduce the instructions by optimizing aggregates and loops.
&lt;/p&gt;

&lt;p&gt;
This is bad from the debug perspective and thus scores low on dexter.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgae29aae" class="outline-3"&gt;
&lt;h3 id="orgae29aae"&gt;Optimized vs unoptimized debugging&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgae29aae"&gt;
&lt;p&gt;
An optimizers job is to make the code execute faster on the given 
machine. This comes at the cost of modifying the code to a point
that it no longer resembles the source material. Thus we rely on
the descriptive power of the standard that is used to encode DI.
&lt;/p&gt;

&lt;p&gt;
Passes that move code around or shorten the execution paths like
SROA and LICM should go to great lengths to preserve the debug 
intrinsics that correspond the the name and value of the variables.
It would be an unrealistic goal to try and keep the stepping behavior
inside a debugger intact after running such passes. 
&lt;/p&gt;

&lt;p&gt;
Instead different optimization methods can be used when debugging
is a high priority. Ones that don't move code around as much and of course
result in longer execution times, but what they lose in speed they give
back with a more robust debug experience.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1f4f0a5" class="outline-2"&gt;
&lt;h2 id="org1f4f0a5"&gt;Conclusion&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1f4f0a5"&gt;
&lt;p&gt;
SROA does a very good job preserving all the important Debug Information
that it's given. On the other hand it significantly impacts the debug
user experience but there is nothing that can be done about it as this is 
the nature of the transformation.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://gramanas.github.io/posts/sroa-debug-experience-and-dexter-thoughts/</guid><pubDate>Wed, 06 Jun 2018 14:00:29 GMT</pubDate></item><item><title>SROA on amalgamated sqlite source</title><link>https://gramanas.github.io/posts/sroa-on-amalgamated-sqlite-source/</link><dc:creator>Anastasis Grammenos</dc:creator><description>&lt;div id="outline-container-org378c6ad" class="outline-2"&gt;
&lt;h2 id="org378c6ad"&gt;Introduction&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org378c6ad"&gt;
&lt;p&gt;
&lt;code&gt;SROA&lt;/code&gt; is an early stage pass running at the very beginning of the pipeline in &lt;code&gt;-O{1,2,3}&lt;/code&gt;.
Greg Bedwell's report from his DExTer tool shows SROA on function as one of the major
culprits of Debug Info loss.
&lt;/p&gt;

&lt;p&gt;
With debugify-each partially done I tried testing this on the amalgamated sqlite source.
&lt;/p&gt;

&lt;p&gt;
The steps are as follows:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# generate IR file without debug info and optnone&lt;/span&gt;
clang -O0 -Xclang -disable-O0-optnone -S -emit-llvm sqlite3.c -o sqlite

&lt;span class="c1"&gt;# run opt&lt;/span&gt;
opt -sroa -debugify-each sqlite -disable-output &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt; results
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4c1bdb0" class="outline-2"&gt;
&lt;h2 id="org4c1bdb0"&gt;Results&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org4c1bdb0"&gt;
&lt;p&gt;
&lt;a href="https://gramanas.github.io/sroa-results.csv"&gt;Here&lt;/a&gt; is the full results file.
&lt;/p&gt;

&lt;p&gt;
The results were gather by &lt;code&gt;grep -c&lt;/code&gt;'ing the results file
according to the error's message.
&lt;/p&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-right"&gt;

&lt;col class="org-right"&gt;

&lt;col class="org-right"&gt;

&lt;col class="org-right"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;SROA runs&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;FAIL&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;PASS&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;empty DebugLoc&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;Missing line warnings&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;1978&lt;/td&gt;
&lt;td class="org-right"&gt;1100&lt;/td&gt;
&lt;td class="org-right"&gt;878&lt;/td&gt;
&lt;td class="org-right"&gt;5214&lt;/td&gt;
&lt;td class="org-right"&gt;75166&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
What's worth noticing is that the only error that SROA produces is that of empty
debug locations. It does not report any missing DILocalVariables or llvm.dbg.value intrinsics.
Thus all of the 1100 SROA runs that failed are due to empty debug locations.
&lt;/p&gt;

&lt;p&gt;
Also, while skimming through the results file I noticed that the instructions with
missing DL were &lt;code&gt;phi&lt;/code&gt; instructions. To confirm this I did 
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;grep &lt;span class="s2"&gt;"ERROR: Instruction"&lt;/span&gt; results &lt;span class="p"&gt;|&lt;/span&gt; grep phi -c
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
witch gives us a result of &lt;code&gt;5214&lt;/code&gt; and this means that all
the instructions with missing Debug Loc are &lt;code&gt;phi&lt;/code&gt; instructions.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge1b8157" class="outline-2"&gt;
&lt;h2 id="orge1b8157"&gt;Conclusion&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orge1b8157"&gt;
&lt;p&gt;
This implies SROA does a pretty good job of preserving debug values.
&lt;/p&gt;

&lt;p&gt;
The DExTer results are not in line with what I've found though. This might be for a number of
reasons. E.g. it could score so low due to the DebugLoc loss. Also debugify doesn't 
test the backend so it's going to detect a narrower set of issues.
&lt;/p&gt;

&lt;p&gt;
Do you have any ideas as to why this happens?
Can you confirm the results?
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://gramanas.github.io/posts/sroa-on-amalgamated-sqlite-source/</guid><pubDate>Wed, 30 May 2018 11:49:10 GMT</pubDate></item><item><title>Week 2</title><link>https://gramanas.github.io/posts/week-2/</link><dc:creator>Anastasis Grammenos</dc:creator><description>&lt;p&gt;
This past days I focused on some missing Debug Loc that occurred at &lt;code&gt;store&lt;/code&gt; instructions
at the function prologue.
&lt;/p&gt;

&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;Preserving the scope&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Instructions on the function prologue are auto-generated and do not correspond the "real" code.
Thus the Debug Location can't have a valid line number.
&lt;/p&gt;

&lt;p&gt;
But the Debug Location metadata contains scope information as well, witch is useful.
Especially after the passes mix and mash the code to form the optimized module.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;Background&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
While investigating the SROA pass for missing DI occurrences, there was a test with a &lt;code&gt;phi&lt;/code&gt;
induction that was missing Debug Loc. The problem was then narrowed down to a mem2reg call
from SROA. As it turned out the mem2reg was correctly sourcing the &lt;code&gt;phi&lt;/code&gt; debug location
from the combined stores, so the problem had to be that there was to DI present at all.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;Proposed Solution&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
Hence this &lt;a href="https://reviews.llvm.org/D47097"&gt;patch&lt;/a&gt; was posted in phab.
&lt;/p&gt;

&lt;p&gt;
There is some talk about whether this change is wanted or not, since the 
DI in the instructions of the function prologue is intended to be missing.
&lt;/p&gt;

&lt;p&gt;
Although &lt;code&gt;test1&lt;/code&gt; clearly shows a phi with missing debug Loc that after the patch is
applied no longer has this problem. 
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://gramanas.github.io/posts/week-2/</guid><pubDate>Mon, 28 May 2018 15:11:00 GMT</pubDate></item><item><title>Week 1: debugify-each</title><link>https://gramanas.github.io/posts/week-1-debugify-each/</link><dc:creator>Anastasis Grammenos</dc:creator><description>&lt;p&gt;
A first iteration of &lt;a href="https://reviews.llvm.org/D46525"&gt;Debugify-each&lt;/a&gt; has landed earlier this week. The tool works as expected
but it's a bit rough around the edges.
&lt;/p&gt;

&lt;p&gt;
For starters debugify only prints if a pass passed or failed, and not the pass name.
That was not a problem before debugify-each because you knew in what pass you would
run debugify. Now running debugify-each will fill the output with PASS or FAIL
without any information about the name of the pass.
I authored a &lt;a href="https://reviews.llvm.org/D46908"&gt;patch&lt;/a&gt; to fix that.
&lt;/p&gt;

&lt;p&gt;
Another problem is that when running debugify-each in one of the standard pipelines (&lt;code&gt;-O{1-3}&lt;/code&gt;) it will
fill the terminal with it's output – both errors and whether the pass failed or passed
the check-debugify.
&lt;/p&gt;

&lt;p&gt;
This is not the correct way a tool like debugify should work. A user should be able to 
pipe opt's output to other tools while also using debugify-each. To remedy this
another &lt;a href="https://reviews.llvm.org/D46941"&gt;patch&lt;/a&gt; redirects the warnings and errors to &lt;code&gt;stderr&lt;/code&gt; and as a follow-up
debugify should dump it's results to a file.
&lt;/p&gt;</description><guid>https://gramanas.github.io/posts/week-1-debugify-each/</guid><pubDate>Wed, 16 May 2018 14:02:07 GMT</pubDate></item><item><title>Less than a week to go</title><link>https://gramanas.github.io/posts/less-that-a-week-to-go/</link><dc:creator>Anastasis Grammenos</dc:creator><description>&lt;p&gt;
Less than a week remains until the coding period officially starts.
Since the last post a few things changed. For starters I didn't
get to implement the debugify-each mode cause someone else 
already had a semi working implementation for it, witch
recently landed for &lt;a href="https://reviews.llvm.org/D46525"&gt;reviews&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
Meanwhile using data from a &lt;a href="https://llvm.org/devmtg/2018-04/talks.html#Lightning_11"&gt;talk&lt;/a&gt; given earlier this year 
we figured that SROA reports a lot of DI Loss occurrences and debugify confirms that.
It's also pretty early in the pipeline, so it's even more important.
So, I've been reading through the code and learning about it. A great help
has been &lt;a href="https://gcc.gnu.org/wiki/summit2010?action=AttachFile&amp;amp;do=get&amp;amp;target=jambor.pdf"&gt;this&lt;/a&gt; paper which tries to explain the goals of the
scalar replacement of aggregates.
&lt;/p&gt;

&lt;p&gt;
SORA is a big and complicated pass. I found this &lt;a href="https://lists.llvm.org/pipermail/llvm-dev/2012-August/052682.html"&gt;mail&lt;/a&gt; from way back
then from Chandler Carruth (who rewrote the pass to it's current form),
that explains the basic underlying logic of the partitioning and splitting
that takes place in the algorithm.
&lt;/p&gt;

&lt;p&gt;
There is still a lot left for me to begin to understand how the pass works,
and as a way of doing that I am currently hunting down when the following DI loss occurs:
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;Before SROA:&lt;/code&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;entry:
  %a.addr = alloca i32, align 4
  %n.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store i32 %a, i32* %a.addr, align 4, !tbaa !9
  store i32 %n, i32* %n.addr, align 4, !tbaa !9
  %0 = bitcast i32* %i to i8*, !dbg !13
  call void @llvm.lifetime.start(i64 4, i8* %0) #2, !dbg !13
  store i32 0, i32* %i, align 4, !dbg !14, !tbaa !9
  br label %for.cond, !dbg !13

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4, !dbg !15, !tbaa !9
  %2 = load i32, i32* %n.addr, align 4, !dbg !17, !tbaa !9
  %cmp = icmp slt i32 %1, %2, !dbg !18
  br i1 %cmp, label %for.body, label %for.cond.cleanup, !dbg !19
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;code&gt;After SROA:&lt;/code&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;entry:
  br label %for.cond, !dbg !9

for.cond:                                         ; preds = %for.inc, %entry
  %a.addr.0 = phi i32 [ %a, %entry ], [ %0, %for.inc ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ], !dbg !10
  %cmp = icmp slt i32 %i.0, %n, !dbg !12
  br i1 %cmp, label %for.body, label %for.cond.cleanup, !dbg !14
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Notice the missing DI in the first φ instruction of the &lt;code&gt;for.cond&lt;/code&gt; block.
&lt;/p&gt;

&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;Closing thoughts&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
I am still very disoriented in the codebase and I am trying to understand 
how things interact with each other. I believe I have made some progress 
but there are still so many things to read and learn and I haven't even 
started to code yet! 
&lt;/p&gt;

&lt;p&gt;
The community is extremely active, the code is well
documented, the dev tools are amazing and every singe day I spend
reading code and documentation I learn countless new exciting things. 
As much as I am scared of the vastness of the project I am also excited
to have this chance to work with all these great developers.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://gramanas.github.io/posts/less-that-a-week-to-go/</guid><pubDate>Wed, 09 May 2018 23:42:17 GMT</pubDate></item><item><title>Community Bonding</title><link>https://gramanas.github.io/posts/community-bonding/</link><dc:creator>Anastasis Grammenos</dc:creator><description>&lt;p&gt;
My proposal was accepted!
&lt;/p&gt;

&lt;p&gt;
For the next few days it's the community bonding period. I will take advantage
of this time to let the community know about my project and it's goals, as well
as get a head start on the coding period.
&lt;/p&gt;

&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;Starting the project&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
The first step to improving the debugging of optimized code is to measure
where we lose Debug information.
Verdant has already created the tool to do that. It's the &lt;a href="https://reviews.llvm.org/D40512"&gt;debugify mode&lt;/a&gt;.
Currently &lt;code&gt;debugify&lt;/code&gt; is a &lt;code&gt;ModulePass&lt;/code&gt; and works like &lt;a href="https://gramanas.github.io/posts/finding-debuginfo-loss/"&gt;that&lt;/a&gt;. 
It needs to be refactored into a &lt;code&gt;FunctionPass&lt;/code&gt; while keeping the
same underlying logic. That way it will be managed from the &lt;code&gt;FunctionPassManager&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Next the opt tool should have a custom &lt;code&gt;PassManager&lt;/code&gt; that injects the new
debugify before a pass and then the new check-debugify after it. This will
be a new mode called debugify-each. It will basically gather DI loss from
every pass in the pipeline.
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;Debugify&lt;/code&gt; as &lt;code&gt;ModulePass&lt;/code&gt; will still be available but it will be a wrapper
around the &lt;code&gt;FunctionPass&lt;/code&gt; one.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;OK, I got the data. Now what?&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
The resulting DI loss occurrences will be stored into some kind of human readable
data serialization format, like JSON or YAML.
&lt;/p&gt;

&lt;p&gt;
More on that on a later post.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://gramanas.github.io/posts/community-bonding/</guid><pubDate>Wed, 25 Apr 2018 15:09:41 GMT</pubDate></item><item><title>Finding DebugInfo Loss</title><link>https://gramanas.github.io/posts/finding-debuginfo-loss/</link><dc:creator>Anastasis Grammenos</dc:creator><description>&lt;p&gt;
In order to fix &lt;code&gt;DebugInfo&lt;/code&gt; loss I need to find where and when it occurs.
Many transformations result in &lt;code&gt;DI&lt;/code&gt; loss due to the simple fact that they change
and optimize code and thus the resulting llvm IR doesn't match the
original code.
&lt;/p&gt;

&lt;p&gt;
The opt tool has the &lt;code&gt;-debugify&lt;/code&gt; and &lt;code&gt;-check-debugify&lt;/code&gt; flags to attach
&lt;code&gt;DI&lt;/code&gt; to everything and then check if it's correct.
&lt;/p&gt;

&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;Find culprit transformations&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
With a simple bash script I can run tests under a transformation folder
like so:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; i in &lt;span class="k"&gt;$(&lt;/span&gt;ls ~/code/llvm/test/Transforms/&lt;span class="nv"&gt;$TRANSFORMATION&lt;/span&gt;/*.ll -1&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; 
    &lt;span class="nb"&gt;echo&lt;/span&gt; -e &lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="s2"&gt;":\n-------"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    opt -debugify -&lt;span class="nv"&gt;$TRANSFORMATION&lt;/span&gt; -check-debugify -disable-output &lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; -e &lt;span class="s2"&gt;"-------\n"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;span class="k"&gt;done&lt;/span&gt; &amp;gt; results &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
and then proceed to view the results.
&lt;/p&gt;

&lt;p&gt;
For example here is the command for the LICM transformation:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; i in &lt;span class="k"&gt;$(&lt;/span&gt;ls ~/code/llvm/test/Transforms/LICM/*.ll -1&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; 
    &lt;span class="nb"&gt;echo&lt;/span&gt; -e &lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="s2"&gt;":\n-------"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    opt -debugify -licm -check-debugify -disable-output &lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="nb"&gt;echo&lt;/span&gt; -e &lt;span class="s2"&gt;"-------\n"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;span class="k"&gt;done&lt;/span&gt; &amp;gt; results &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Here is a sample of the &lt;code&gt;results&lt;/code&gt; file:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/home/gramanas/code/llvm/test/Transforms/LICM/2003-02-27-StoreSinkPHIs.ll:
-------
CheckDebugify: PASS
-------

/home/gramanas/code/llvm/test/Transforms/LICM/2003-05-02-LoadHoist.ll:
-------
ERROR: Instruction with empty DebugLoc --   %B.lcssa &lt;span class="o"&gt;=&lt;/span&gt; phi i32 &lt;span class="o"&gt;[&lt;/span&gt; %B, %Loop &lt;span class="o"&gt;]&lt;/span&gt;
CheckDebugify: FAIL
-------

/home/gramanas/code/llvm/test/Transforms/LICM/2004-09-14-AliasAnalysisInvalidate.ll:
-------
WARNING: Missing line &lt;span class="m"&gt;3&lt;/span&gt;
WARNING: Missing line &lt;span class="m"&gt;4&lt;/span&gt;
CheckDebugify: PASS
-------

/home/gramanas/code/llvm/test/Transforms/LICM/2003-02-28-PromoteDifferentType.ll:
-------
ERROR: Instruction with empty DebugLoc --   %P2 &lt;span class="o"&gt;=&lt;/span&gt; bitcast i32* %P to i8*
WARNING: Missing line &lt;span class="m"&gt;3&lt;/span&gt;
CheckDebugify: FAIL
-------
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://gramanas.github.io/posts/finding-debuginfo-loss/</guid><pubDate>Tue, 27 Mar 2018 12:51:52 GMT</pubDate></item><item><title>Debug Information</title><link>https://gramanas.github.io/posts/debug-information/</link><dc:creator>Anastasis Grammenos</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;Developer resources&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://llvm.org/docs/SourceLevelDebugging.html"&gt;Source Level Debugging with LLVM&lt;/a&gt; -llvm docs
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://gramanas.github.io/posts/debug-information/</guid><pubDate>Wed, 21 Mar 2018 14:50:57 GMT</pubDate></item></channel></rss>